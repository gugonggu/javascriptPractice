// 숫자 n이 주어질 때 2부터 n까지의 소수의 개수를 반환하는 문제입니다.

// 처음에는 2중 for문을 통해 숫자 하나마다 2부터 숫자까지 나머지를 계산하며 소수를 계산했지만
// 시간초과가 떠서 더 효율적인 방법인 에라토스테네스의 체라는 방법을 사용했습니다.

// 우선 array와 fill을 사용해 n + 1 크기만큼의 배열을 0으로 초기화 시키고,
// 2부터 n까지 i를 할당시켜 줬습니다.
// 그 후 2중 for문을 돌리는데
// 첫 번째 for문의 조건 i * i가 들어가는 이유는 예를 들어 11**2 > 120일 때 11보다 작은 숫자의 배수만 검사해도 모든 소수가 다 걸러지기 때문입니다.
// 내부 for문을 통해 i의 1의 배수를 제외한 모든 숫자를 0으로 처리해줘서 숫자의 배수를 제거해줍니다.
// 최종적으로 배열에서 0을 필터링하고 난 뒤 그 배열의 길이를 반환해 소수의 개수를 반환해주었습니다.

function solution(n) {
    const arr = new Array(n + 1).fill(0);
    for (let i = 2; i <= n; i++) {
        arr[i] = i;
    }
    for (let i = 0; i * i < n; i++) {
        if (arr[i] === 0) continue;
        for (let j = 2; i * j <= n; j++) {
            arr[i * j] = 0;
        }
    }
    return arr.filter((v) => v !== 0).length;
}
